// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class newTrove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("arrayIndex", Value.fromBigInt(BigInt.zero()));
    this.set("debt", Value.fromBigInt(BigInt.zero()));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save newTrove entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save newTrove entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("newTrove", id.toString(), this);
    }
  }

  static load(id: string): newTrove | null {
    return changetype<newTrove | null>(store.get("newTrove", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get arrayIndex(): BigInt {
    let value = this.get("arrayIndex");
    return value!.toBigInt();
  }

  set arrayIndex(value: BigInt) {
    this.set("arrayIndex", Value.fromBigInt(value));
  }

  get debt(): BigInt {
    let value = this.get("debt");
    return value!.toBigInt();
  }

  set debt(value: BigInt) {
    this.set("debt", Value.fromBigInt(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class updatedTrove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("debt", Value.fromBigInt(BigInt.zero()));
    this.set("tokens", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
    this.set("collsIn", Value.fromBytesArray(new Array(0)));
    this.set("amountsIn", Value.fromBigIntArray(new Array(0)));
    this.set("collsOut", Value.fromBytesArray(new Array(0)));
    this.set("amountsOut", Value.fromBigIntArray(new Array(0)));
    this.set("leverages", Value.fromBigIntArray(new Array(0)));
    this.set("maxSlippages", Value.fromBigIntArray(new Array(0)));
    this.set("upperHint", Value.fromBytes(Bytes.empty()));
    this.set("lowerHint", Value.fromBytes(Bytes.empty()));
    this.set("maxFeePercentage", Value.fromBigInt(BigInt.zero()));
    this.set("operation", Value.fromString(""));
    this.set("currentICR", Value.fromBigInt(BigInt.zero()));
    this.set("YUSDchange", Value.fromBigInt(BigInt.zero()));
    this.set("isDebtIncrease", Value.fromBoolean(false));
    this.set("eventAddress", Value.fromBytes(Bytes.empty()));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
    this.set("length", Value.fromI32(0));
    this.set("temp", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save updatedTrove entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save updatedTrove entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("updatedTrove", id.toString(), this);
    }
  }

  static load(id: string): updatedTrove | null {
    return changetype<updatedTrove | null>(store.get("updatedTrove", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get debt(): BigInt {
    let value = this.get("debt");
    return value!.toBigInt();
  }

  set debt(value: BigInt) {
    this.set("debt", Value.fromBigInt(value));
  }

  get tokens(): Array<Bytes> {
    let value = this.get("tokens");
    return value!.toBytesArray();
  }

  set tokens(value: Array<Bytes>) {
    this.set("tokens", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }

  get collsIn(): Array<Bytes> {
    let value = this.get("collsIn");
    return value!.toBytesArray();
  }

  set collsIn(value: Array<Bytes>) {
    this.set("collsIn", Value.fromBytesArray(value));
  }

  get amountsIn(): Array<BigInt> {
    let value = this.get("amountsIn");
    return value!.toBigIntArray();
  }

  set amountsIn(value: Array<BigInt>) {
    this.set("amountsIn", Value.fromBigIntArray(value));
  }

  get collsOut(): Array<Bytes> {
    let value = this.get("collsOut");
    return value!.toBytesArray();
  }

  set collsOut(value: Array<Bytes>) {
    this.set("collsOut", Value.fromBytesArray(value));
  }

  get amountsOut(): Array<BigInt> {
    let value = this.get("amountsOut");
    return value!.toBigIntArray();
  }

  set amountsOut(value: Array<BigInt>) {
    this.set("amountsOut", Value.fromBigIntArray(value));
  }

  get leverages(): Array<BigInt> {
    let value = this.get("leverages");
    return value!.toBigIntArray();
  }

  set leverages(value: Array<BigInt>) {
    this.set("leverages", Value.fromBigIntArray(value));
  }

  get maxSlippages(): Array<BigInt> {
    let value = this.get("maxSlippages");
    return value!.toBigIntArray();
  }

  set maxSlippages(value: Array<BigInt>) {
    this.set("maxSlippages", Value.fromBigIntArray(value));
  }

  get upperHint(): Bytes {
    let value = this.get("upperHint");
    return value!.toBytes();
  }

  set upperHint(value: Bytes) {
    this.set("upperHint", Value.fromBytes(value));
  }

  get lowerHint(): Bytes {
    let value = this.get("lowerHint");
    return value!.toBytes();
  }

  set lowerHint(value: Bytes) {
    this.set("lowerHint", Value.fromBytes(value));
  }

  get maxFeePercentage(): BigInt {
    let value = this.get("maxFeePercentage");
    return value!.toBigInt();
  }

  set maxFeePercentage(value: BigInt) {
    this.set("maxFeePercentage", Value.fromBigInt(value));
  }

  get operation(): string {
    let value = this.get("operation");
    return value!.toString();
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get currentICR(): BigInt {
    let value = this.get("currentICR");
    return value!.toBigInt();
  }

  set currentICR(value: BigInt) {
    this.set("currentICR", Value.fromBigInt(value));
  }

  get YUSDchange(): BigInt {
    let value = this.get("YUSDchange");
    return value!.toBigInt();
  }

  set YUSDchange(value: BigInt) {
    this.set("YUSDchange", Value.fromBigInt(value));
  }

  get isDebtIncrease(): boolean {
    let value = this.get("isDebtIncrease");
    return value!.toBoolean();
  }

  set isDebtIncrease(value: boolean) {
    this.set("isDebtIncrease", Value.fromBoolean(value));
  }

  get eventAddress(): Bytes {
    let value = this.get("eventAddress");
    return value!.toBytes();
  }

  set eventAddress(value: Bytes) {
    this.set("eventAddress", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }

  get length(): i32 {
    let value = this.get("length");
    return value!.toI32();
  }

  set length(value: i32) {
    this.set("length", Value.fromI32(value));
  }

  get temp(): string {
    let value = this.get("temp");
    return value!.toString();
  }

  set temp(value: string) {
    this.set("temp", Value.fromString(value));
  }
}

export class YUSDPaid extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save YUSDPaid entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save YUSDPaid entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("YUSDPaid", id.toString(), this);
    }
  }

  static load(id: string): YUSDPaid | null {
    return changetype<YUSDPaid | null>(store.get("YUSDPaid", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}

export class VariablePaid extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VariablePaid entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save VariablePaid entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("VariablePaid", id.toString(), this);
    }
  }

  static load(id: string): VariablePaid | null {
    return changetype<VariablePaid | null>(store.get("VariablePaid", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}

export class totalStake extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("token", Value.fromBytes(Bytes.empty()));
    this.set("newTotalStakes", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save totalStake entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save totalStake entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("totalStake", id.toString(), this);
    }
  }

  static load(id: string): totalStake | null {
    return changetype<totalStake | null>(store.get("totalStake", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get newTotalStakes(): BigInt {
    let value = this.get("newTotalStakes");
    return value!.toBigInt();
  }

  set newTotalStakes(value: BigInt) {
    this.set("newTotalStakes", Value.fromBigInt(value));
  }
}

export class newLiquidation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("liquidatedAmount", Value.fromBigInt(BigInt.zero()));
    this.set("totalYUSDGasCompensation", Value.fromBigInt(BigInt.zero()));
    this.set("totalCollTokens", Value.fromBytesArray(new Array(0)));
    this.set("totalCollAmounts", Value.fromBigIntArray(new Array(0)));
    this.set("totalCollGasCompTokens", Value.fromBytesArray(new Array(0)));
    this.set("totalCollGasCompAmounts", Value.fromBigIntArray(new Array(0)));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save newLiquidation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save newLiquidation entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("newLiquidation", id.toString(), this);
    }
  }

  static load(id: string): newLiquidation | null {
    return changetype<newLiquidation | null>(store.get("newLiquidation", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get liquidatedAmount(): BigInt {
    let value = this.get("liquidatedAmount");
    return value!.toBigInt();
  }

  set liquidatedAmount(value: BigInt) {
    this.set("liquidatedAmount", Value.fromBigInt(value));
  }

  get totalYUSDGasCompensation(): BigInt {
    let value = this.get("totalYUSDGasCompensation");
    return value!.toBigInt();
  }

  set totalYUSDGasCompensation(value: BigInt) {
    this.set("totalYUSDGasCompensation", Value.fromBigInt(value));
  }

  get totalCollTokens(): Array<Bytes> {
    let value = this.get("totalCollTokens");
    return value!.toBytesArray();
  }

  set totalCollTokens(value: Array<Bytes>) {
    this.set("totalCollTokens", Value.fromBytesArray(value));
  }

  get totalCollAmounts(): Array<BigInt> {
    let value = this.get("totalCollAmounts");
    return value!.toBigIntArray();
  }

  set totalCollAmounts(value: Array<BigInt>) {
    this.set("totalCollAmounts", Value.fromBigIntArray(value));
  }

  get totalCollGasCompTokens(): Array<Bytes> {
    let value = this.get("totalCollGasCompTokens");
    return value!.toBytesArray();
  }

  set totalCollGasCompTokens(value: Array<Bytes>) {
    this.set("totalCollGasCompTokens", Value.fromBytesArray(value));
  }

  get totalCollGasCompAmounts(): Array<BigInt> {
    let value = this.get("totalCollGasCompAmounts");
    return value!.toBigIntArray();
  }

  set totalCollGasCompAmounts(value: Array<BigInt>) {
    this.set("totalCollGasCompAmounts", Value.fromBigIntArray(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}

export class newRedemption extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("attemptedYUSDAmount", Value.fromBigInt(BigInt.zero()));
    this.set("actualYUSDAmount", Value.fromBigInt(BigInt.zero()));
    this.set("YUSDPaid", Value.fromBigInt(BigInt.zero()));
    this.set("tokens", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save newRedemption entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save newRedemption entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("newRedemption", id.toString(), this);
    }
  }

  static load(id: string): newRedemption | null {
    return changetype<newRedemption | null>(store.get("newRedemption", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get attemptedYUSDAmount(): BigInt {
    let value = this.get("attemptedYUSDAmount");
    return value!.toBigInt();
  }

  set attemptedYUSDAmount(value: BigInt) {
    this.set("attemptedYUSDAmount", Value.fromBigInt(value));
  }

  get actualYUSDAmount(): BigInt {
    let value = this.get("actualYUSDAmount");
    return value!.toBigInt();
  }

  set actualYUSDAmount(value: BigInt) {
    this.set("actualYUSDAmount", Value.fromBigInt(value));
  }

  get YUSDPaid(): BigInt {
    let value = this.get("YUSDPaid");
    return value!.toBigInt();
  }

  set YUSDPaid(value: BigInt) {
    this.set("YUSDPaid", Value.fromBigInt(value));
  }

  get tokens(): Array<Bytes> {
    let value = this.get("tokens");
    return value!.toBytesArray();
  }

  set tokens(value: Array<Bytes>) {
    this.set("tokens", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}

export class farmOperation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromBytes(Bytes.empty()));
    this.set("boostedPartition", Value.fromBigInt(BigInt.zero()));
    this.set("amountOfLP", Value.fromBigInt(BigInt.zero()));
    this.set("rewardRate", Value.fromBigInt(BigInt.zero()));
    this.set("userFactor", Value.fromBigInt(BigInt.zero()));
    this.set("sumOfFactors", Value.fromBigInt(BigInt.zero()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("operation", Value.fromString(""));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save farmOperation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save farmOperation entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("farmOperation", id.toString(), this);
    }
  }

  static load(id: string): farmOperation | null {
    return changetype<farmOperation | null>(store.get("farmOperation", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get boostedPartition(): BigInt {
    let value = this.get("boostedPartition");
    return value!.toBigInt();
  }

  set boostedPartition(value: BigInt) {
    this.set("boostedPartition", Value.fromBigInt(value));
  }

  get amountOfLP(): BigInt {
    let value = this.get("amountOfLP");
    return value!.toBigInt();
  }

  set amountOfLP(value: BigInt) {
    this.set("amountOfLP", Value.fromBigInt(value));
  }

  get rewardRate(): BigInt {
    let value = this.get("rewardRate");
    return value!.toBigInt();
  }

  set rewardRate(value: BigInt) {
    this.set("rewardRate", Value.fromBigInt(value));
  }

  get userFactor(): BigInt {
    let value = this.get("userFactor");
    return value!.toBigInt();
  }

  set userFactor(value: BigInt) {
    this.set("userFactor", Value.fromBigInt(value));
  }

  get sumOfFactors(): BigInt {
    let value = this.get("sumOfFactors");
    return value!.toBigInt();
  }

  set sumOfFactors(value: BigInt) {
    this.set("sumOfFactors", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get operation(): string {
    let value = this.get("operation");
    return value!.toString();
  }

  set operation(value: string) {
    this.set("operation", Value.fromString(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}

export class collateral extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("status", Value.fromString(""));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save collateral entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save collateral entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("collateral", id.toString(), this);
    }
  }

  static load(id: string): collateral | null {
    return changetype<collateral | null>(store.get("collateral", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}

export class swap extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("startingTokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("endingTokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("minswapAmount", Value.fromBigInt(BigInt.zero()));
    this.set("caller", Value.fromBytes(Bytes.empty()));
    this.set("actualOut", Value.fromBigInt(BigInt.zero()));
    this.set("transaction", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockNum", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save swap entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save swap entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("swap", id.toString(), this);
    }
  }

  static load(id: string): swap | null {
    return changetype<swap | null>(store.get("swap", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get startingTokenAddress(): Bytes {
    let value = this.get("startingTokenAddress");
    return value!.toBytes();
  }

  set startingTokenAddress(value: Bytes) {
    this.set("startingTokenAddress", Value.fromBytes(value));
  }

  get endingTokenAddress(): Bytes {
    let value = this.get("endingTokenAddress");
    return value!.toBytes();
  }

  set endingTokenAddress(value: Bytes) {
    this.set("endingTokenAddress", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get minswapAmount(): BigInt {
    let value = this.get("minswapAmount");
    return value!.toBigInt();
  }

  set minswapAmount(value: BigInt) {
    this.set("minswapAmount", Value.fromBigInt(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    return value!.toBytes();
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get actualOut(): BigInt {
    let value = this.get("actualOut");
    return value!.toBigInt();
  }

  set actualOut(value: BigInt) {
    this.set("actualOut", Value.fromBigInt(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    return value!.toBytes();
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNum(): BigInt {
    let value = this.get("blockNum");
    return value!.toBigInt();
  }

  set blockNum(value: BigInt) {
    this.set("blockNum", Value.fromBigInt(value));
  }
}
